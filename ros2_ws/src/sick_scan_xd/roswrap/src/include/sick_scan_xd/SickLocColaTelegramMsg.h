#include "sick_scan/sick_scan_base.h" /* Base definitions included in all header files, added by add_sick_scan_base_header.py. Do not edit this line. */
// Generated by gencpp from file sick_scan/SickLocColaTelegramMsg.msg
// DO NOT EDIT!


#ifndef SICK_SCAN_MESSAGE_SICKLOCCOLATELEGRAMMSG_H
#define SICK_SCAN_MESSAGE_SICKLOCCOLATELEGRAMMSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace sick_scan_xd
{
template <class ContainerAllocator>
struct SickLocColaTelegramMsg_
{
  typedef SickLocColaTelegramMsg_<ContainerAllocator> Type;

  SickLocColaTelegramMsg_()
    : header()
    , command_type(0)
    , command_name()
    , parameter()  {
    }
  SickLocColaTelegramMsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , command_type(0)
    , command_name(_alloc)
    , parameter(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int32_t _command_type_type;
  _command_type_type command_type;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _command_name_type;
  _command_name_type command_name;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _parameter_type;
  _parameter_type parameter;





  typedef std::shared_ptr< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> > Ptr;
  typedef std::shared_ptr< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> const> ConstPtr;

}; // struct SickLocColaTelegramMsg_

typedef ::sick_scan_xd::SickLocColaTelegramMsg_<std::allocator<void> > SickLocColaTelegramMsg;

typedef std::shared_ptr< ::sick_scan_xd::SickLocColaTelegramMsg > SickLocColaTelegramMsgPtr;
typedef std::shared_ptr< ::sick_scan_xd::SickLocColaTelegramMsg const> SickLocColaTelegramMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator1> & lhs, const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.command_type == rhs.command_type &&
    lhs.command_name == rhs.command_name &&
    lhs.parameter == rhs.parameter;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator1> & lhs, const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace sick_scan_xd

namespace roswrap
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fda058e73f190c37b2ae74d5f8aa66d7";
  }

  static const char* value(const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfda058e73f190c37ULL;
  static const uint64_t static_value2 = 0xb2ae74d5f8aa66d7ULL;
};

template<class ContainerAllocator>
struct DataType< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "sick_scan/SickLocColaTelegramMsg";
  }

  static const char* value(const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Definition of ros message SickLocColaTelegramMsg.\n"
"# SickLocColaTelegramMsg publishes Cola-ASCII telegrams for sick localization.\n"
"# See Technical_information_Telegram_Listing_NAV_LOC_en_IM0076556.PDF for further details\n"
"# about Cola telgrams\n"
"\n"
"std_msgs/Header header        # ROS Header with sequence id, timestamp and frame id\n"
"\n"
"int32 command_type   # One of the SOPAS Commands sRN (1, Read by name request) or sRA (2, Read by name response) or sMN (3, Method by name request) or sMA (4, Method by name response) or sWN (5, Write by name request)\n"
"\n"
"string command_name  # Name of command like \"SetAccessMode\", \"LocSetResultPoseEnabled\", \"LocRequestTimestamp\", etc.\n"
"\n"
"string[] parameter   # Optional parameter, type and number parameter depend on the command, f.e. \"sMN SetAccessMode 3 F4724744\" with 2 parameter\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace roswrap

namespace roswrap
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.command_type);
      stream.next(m.command_name);
      stream.next(m.parameter);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SickLocColaTelegramMsg_

} // namespace serialization
} // namespace roswrap

namespace roswrap
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::sick_scan_xd::SickLocColaTelegramMsg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "command_type: ";
    Printer<int32_t>::stream(s, indent + "  ", v.command_type);
    s << indent << "command_name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.command_name);
    s << indent << "parameter[]" << std::endl;
    for (size_t i = 0; i < v.parameter.size(); ++i)
    {
      s << indent << "  parameter[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.parameter[i]);
    }
  }
};

} // namespace message_operations
} // namespace roswrap

#endif // SICK_SCAN_MESSAGE_SICKLOCCOLATELEGRAMMSG_H
