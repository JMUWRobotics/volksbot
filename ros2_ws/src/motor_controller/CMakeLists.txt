cmake_minimum_required(VERSION 3.5)
project(motor_controller)

# Add standard ROS 2 compile options
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic -O3)
endif()

# Set C++ standard to C++14
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find necessary ROS 2 packages
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(tf2_geometry_msgs REQUIRED)
find_package(volksface REQUIRED)
 

# uncomment the following line if msg/srv/action files are placed within this package
# finds the target generated by rosidl, necessary to link executables/libraries to target
# rosidl_get_typesupport_target(cpp_typesupport_target ${PROJECT_NAME} "rosidl_typesupport_cpp")

#------------------------------------------------------------------------------
# EPOS - library
#------------------------------------------------------------------------------
# Automatically detect architecture and link correct libEposCmd version
include(cmake/TargetArch.cmake)
target_architecture(TARGET_ARCH)
message("Detected architecture: ${TARGET_ARCH}")
if(${TARGET_ARCH} STREQUAL "x86_64")
  set(EPOS2_CMD_LIBRARY "${PROJECT_SOURCE_DIR}/libEposCmd/x86_64/libEposCmd.so")
elseif(${TARGET_ARCH} STREQUAL "i386")
  set(EPOS2_CMD_LIBRARY "${PROJECT_SOURCE_DIR}/libEposCmd/x86/libEposCmd.so")
elseif(${TARGET_ARCH} STREQUAL "armv7")
  set(EPOS2_CMD_LIBRARY "${PROJECT_SOURCE_DIR}/libEposCmd/armv7hf/libEposCmd.so")
else()
  message("Unsupported architecture for libEposCmd!")
  set(EPOS2_CMD_LIBRARY "EposCmd" PARENT_SCOPE)
endif()
message("Using EposCmd library: ${EPOS2_CMD_LIBRARY}")
install(FILES ${EPOS2_CMD_LIBRARY} DESTINATION lib)

# Define EPOS2 library
add_library(EPOS2 src/epos2/epos2.cpp)
target_link_libraries(EPOS2 ${EPOS2_CMD_LIBRARY} "${cpp_typesupport_target}")

#------------------------------------------------------------------------------
# VMC - library
#------------------------------------------------------------------------------
# Define VMCLIB library
add_library(VMCLIB
  src/Adapter/CComAdapter.cpp
  src/LayerClasses/CVmc.cpp
  src/SupportClasses/CData.cpp
  src/SupportClasses/CRequest.cpp
  src/LayerClasses/CCommunicationLayer.cpp
  src/StorageClasses/CMotor.cpp
  src/SupportClasses/CError.cpp
  src/SupportClasses/CSendTwo.cpp
  src/LayerClasses/CTranslationLayer.cpp
  src/StorageClasses/CStorage.cpp
  src/SupportClasses/CMessage.cpp
  src/SupportClasses/CTimer.cpp
  src/LayerClasses/CvmcAPI.cpp
  src/SupportClasses/CChannel.cpp
  src/SupportClasses/CMultisend.cpp
  src/SupportClasses/CTimestamp.cpp
)
target_link_libraries(VMCLIB "${cpp_typesupport_target}") 

#------------------------------------------------------------------------------
# Volksbot - Executable
#------------------------------------------------------------------------------
# Define volksbot_node executable
add_executable(motor_controller 
  src/controller.cc
)
set_target_properties(motor_controller PROPERTIES LINK_FLAGS "-pthread")
ament_target_dependencies(motor_controller
  rclcpp
  geometry_msgs
  volksface
)
target_link_libraries(motor_controller VMCLIB EPOS2)

# Install libraries
install(
  TARGETS EPOS2 VMCLIB
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
)

# export VMCLIB to use in other packages
install(TARGETS VMCLIB DESTINATION lib EXPORT mc-targets)
install(EXPORT mc-targets DESTINATION lib/${PROJECT_NAME})

# Install executables
install(
  TARGETS motor_controller
  DESTINATION lib/${PROJECT_NAME}
)

# Export dependencies and libraries
# if other packages includes the 'motor_controller' package, it automatically gets access 
# to the exported dependencies
ament_export_dependencies(rclcpp tf2_geometry_msgs volksface)

ament_package()